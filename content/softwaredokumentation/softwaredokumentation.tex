\part{Softwaredokumentation}

\chapter{Installation}
In diesem Kapitel soll eine Schrittweise Anleitung zur Installation von OpenDataHub auf verschiedenen Plattformen wiedergeben werden.
\section{vagrant}
\xxx[Erstellen Vagrant Dokumentation]
\section{Heroku}
\xxx[evtl alles automatisch?]
\begin{enumerate}
\item Klonen des Git Repositories
\shellcmd{git clone git@github.com:hsr-ba-fs15-dat/vm.git}
\item Heroku toolkit installieren
\item Namen des Servers von Heroku übernehmen.
\xxx[Welche Config files müssen angepasst werden?]
\item Vagrant konfiguration auf heroku pushen.
\shellcmd{vagrant push}
\end{enumerate}Klonen des Git-Repositorys

\section{Deploy per FTP}
\xxx[vagrant nach FTP deployen]

\chapter{Entwicklung}

\section{Entwicklungsumgebung \textendash\ Vagrant}
Vagrant ist eine auf Ruby basierte, freie Anwendung, die das Verwalten und Erstellen von virtuellen Maschinen ermöglicht. Vagrant dient eigentlich als Wrapper zwischen der Virtualisierungssoftware (VirtualBox, VMware, Parallels, etc.) und Systemkonfiguartionswerkzeugen (in unserem Fall Puppet).
Der grosse Mehrwert von Vagrant ergibt sich dadurch, dass es komplett Plattform- und Programmiersprachenunabhängig ist und somit für verschiedene Softwareprojekte verwendet werden kann. Im Vagrantfile wird eine virtuelle Maschine definiert und konfiguriert. Dieses File wird mit dem Projekt in der Versonskontrolle abgelegt, so kann auf den unterschiedlichen Host Systemen gewährleistet werden, dass mit der selben Entwicklungsumgebung gearbeitet werden kann und so alle Abhängigkeiten, ohne das Hostsystem zu beeinflussen, gewährleistet werden.

\subsection{Projektinitalisierung}
\xxx[@remo: das zeug hier ist doch nicht nötig?, erklären wie man eine opendatahub Entwicklungsumgebung aufsetzt, nicht wie man eine eigene VM von scratch konfiguriert]

Ein Projekt wird mit folgendem Befehl initialisiert
\begin{src}{shell}
vagrant init [box-name] [box-url]
\end{src}

 Durch die Angabe des ``box-name'' kann direkt eine entsprechende Vorlage ins Vagrantfile geladen werden. Die URL kann dazu verwendet werden, den Ort an dem sich das Image befindet anzugeben, und diese direkt herunterzuladen. Diese Angaben haben wir im Vagrantfile, bzw. mittels Puppet konfiguriert.


\subsection{Konfiguration}
Die gesamte Konfiguration erfolgt im Vagrantfile. 
\begin{srclst}{ruby}{Syntax-Beispiel eines Vagrantfile (generiert durch puphpet.com)}
require 'yaml'

dir = File.dirname(File.expand_path(__FILE__))

configValues = YAML.load_file("#{dir}/puphpet/config.yaml")
data         = configValues['vagrantfile-local']

Vagrant.require_version '>= 1.6.0'

Vagrant.configure('2') do |config|
  config.vm.box     = "#{data['vm']['box']}"
  config.vm.box_url = "#{data['vm']['box_url']}"

  if data['vm']['hostname'].to_s.strip.length != 0
    config.vm.hostname = "#{data['vm']['hostname']}"
  end
  [...]
end
\end{srclst}

\subsection{Provisioning}
In der Phase Provisioning werden andere Programme, zumeist SCM-Software wie aptitude, aber auch grundlegende Anwendungen wie Shell konfiguriert und parameter übergeben.
Hier ein Auszug eines unsere provisioning files:
\begin{src}{shell}
#!/bin/sh

sudo apt-get update
sudo apt-get upgrade
source ~/.bashrc
sudo wget -qO- https://toolbelt.heroku.com/install-ubuntu.sh | sh
# ------ Frontend
cd /vagrant/webapp/frontend

# Required for SASS
sudo `which gem` install compass

# Cleanup
rm -rf bower_components node_modules

# Install deps

npm install
bower install --config.analytics=false --allow-root


# ------ Backend
cd /vagrant/webapp/backend

# Cleanup
rm -rf env target

# Create virtualenv with existing packages (see config.yaml)
virtualenv --system-site-packages env
source env/bin/activate

# Install all requirements.txt and requirements_dev.txt dependencies
pyb install_dependencies

\end{src}
\subsection{Arbeiten mit Vagrant}
Um eine \gls{vm} zu starten, führt man den Befehl \mintinline{shell}{vagrant up} aus. Beim Ausführen des Befehles wird die \gls{vm} gemäss den Vorgaben im Vagrantfile initialisiert. Später kann man mittels \mintinline{shell}{vagrant ssh} per SSH direkt in die \gls{vm} verbunden werden. Wird die Maschine (vorübergehend) nicht mehr gebraucht, kann mittels \mintinline{shell}{vagrant suspend} die \gls{vm} in den Ruhezustand gebracht werden.
\subsection{Deployment}
Seit der Vagrant Version 1.7 vom Dezember 2014 ist Deployment mittels Vagrant möglich. Durch den Befehl \mintinline{shell}{vagrant push} kann, je nach Konfiguration, auf Heroku, SFTP und FTP sowie durch selbstgeschriebene Kommandozeilenskripte oder Atlas deployed werden.
\\Syntaxbeispiel für einen FTP-push: \cite{vagrant-deployment}
\begin{src}{ruby}
config.push.define "ftp" do |push|
  push.host = "ftp.test.com"
  push.username = "benutzer1"
  push.password = "Passwort1"
  push.secure = false
  push.destination = "/"
  push.dir = "/"
end
\end{src}
\section{Tests}